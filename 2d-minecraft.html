<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>2D Minecraft</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>2D Minecraft Mini</h1>
  <canvas id="game" width="800" height="480"></canvas>

  <div id="ui">
    <div id="hotbar">
      <span data-slot="0" class="slot selected">Erde</span>
      <span data-slot="1" class="slot">Stein</span>
      <span data-slot="2" class="slot">Gras</span>
      <span data-slot="3" class="slot">Holz</span>
    </div>
    <p>Steuerung: A/D = laufen, W = springen, 1‑4 = Block wählen, 
       Links = abbauen, Rechts = setzen, Kamera folgt automatisch.</p>
  </div>

  <script src="game.js"></script>
</body>

  <style> body {
  background: #111;
  color: #eee;
  font-family: system-ui, sans-serif;
  text-align: center;
}

#game {
  background: #66caff;
  border: 3px solid #222;
  image-rendering: pixelated;
  display: block;
  margin: 0 auto;
}

#ui {
  margin-top: 10px;
}

#hotbar {
  display: inline-flex;
  gap: 6px;
  margin-bottom: 6px;
}

.slot {
  padding: 4px 8px;
  border: 2px solid #555;
  border-radius: 4px;
  background: #222;
  color: #eee;
  font-size: 14px;
  cursor: default;
}

.slot.selected {
  border-color: #ffcc00;
  background: #444;
}

</style>

 <script>
   
   const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const TILE_SIZE = 32;
const COLS = Math.floor(canvas.width / TILE_SIZE);
const ROWS = Math.floor(canvas.height / TILE_SIZE);

// Kamera
const camera = {
  x: 0,
  y: 0
};

// Block-Typen
const AIR = 0;
const DIRT = 1;
const STONE = 2;
const GRASS = 3;
const WOOD = 4;

// Weltgröße (kann größer als Canvas sein)
const WORLD_COLS = 200;
const WORLD_ROWS = 60;

const world = [];

// einfache zufällige Welt generieren (Hügel)
function generateWorld() {
  // Start-Höhe
  let groundLevel = 20;

  for (let x = 0; x < WORLD_COLS; x++) {
    // zufällige kleine Änderung der Höhe
    const change = Math.floor(Math.random() * 3) - 1; // -1, 0, +1
    groundLevel += change;
    if (groundLevel < 10) groundLevel = 10;
    if (groundLevel > 40) groundLevel = 40;

    for (let y = 0; y < WORLD_ROWS; y++) {
      if (!world[y]) world[y] = [];

      if (y < groundLevel) {
        world[y][x] = AIR;
      } else if (y === groundLevel) {
        world[y][x] = GRASS;
      } else if (y < groundLevel + 3) {
        world[y][x] = DIRT;
      } else {
        // ab und zu Steinadern
        if (Math.random() < 0.2) {
          world[y][x] = STONE;
        } else {
          world[y][x] = DIRT;
        }
      }
    }

    // ein paar Bäume setzen
    if (Math.random() < 0.08) {
      const trunkHeight = 3 + Math.floor(Math.random() * 2);
      for (let t = 0; t < trunkHeight; t++) {
        const ty = groundLevel - 1 - t;
        if (ty >= 0) {
          world[ty][x] = WOOD;
        }
      }
    }
  }
}

// Spieler
const player = {
  x: 5,
  y: 5,
  vx: 0,
  vy: 0,
  width: 0.6,
  height: 0.9,
  onGround: false
};

const keys = {};
let selectedBlockIndex = 0;

// Inventar / Hotbar: Welche Blöcke sind auswählbar?
const hotbarBlocks = [DIRT, STONE, GRASS, WOOD];

window.addEventListener("keydown", e => {
  keys[e.key.toLowerCase()] = true;

  if (e.key === "1") selectHotbar(0);
  if (e.key === "2") selectHotbar(1);
  if (e.key === "3") selectHotbar(2);
  if (e.key === "4") selectHotbar(3);
});

window.addEventListener("keyup", e => {
  keys[e.key.toLowerCase()] = false;
});

function selectHotbar(index) {
  selectedBlockIndex = index;
  document.querySelectorAll("#hotbar .slot").forEach((el, i) => {
    el.classList.toggle("selected", i === index);
  });
}

// Block-Farbe
function getBlockColor(type) {
  switch (type) {
    case DIRT: return "#7b4a1f";
    case STONE: return "#777777";
    case GRASS: return "#2ecc40";
    case WOOD: return "#8b5a2b";
    default: return null;
  }
}

// Check: solider Block?
function isSolid(x, y) {
  if (x < 0 || x >= WORLD_COLS || y < 0 || y >= WORLD_ROWS) return true;
  const t = world[y][x];
  return t === DIRT || t === STONE || t === GRASS || t === WOOD;
}

// Welt zeichnen (nur sichtbarer Bereich)
function drawWorld() {
  const startCol = Math.floor(camera.x / TILE_SIZE);
  const endCol = startCol + COLS + 1;
  const startRow = Math.floor(camera.y / TILE_SIZE);
  const endRow = startRow + ROWS + 1;

  for (let y = startRow; y < endRow; y++) {
    for (let x = startCol; x < endCol; x++) {
      if (x < 0 || x >= WORLD_COLS || y < 0 || y >= WORLD_ROWS) continue;
      const type = world[y][x];
      const color = getBlockColor(type);
      if (!color) continue;

      const screenX = x * TILE_SIZE - camera.x;
      const screenY = y * TILE_SIZE - camera.y;

      ctx.fillStyle = color;
      ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
    }
  }
}

// Spieler zeichnen
function drawPlayer() {
  const screenX = player.x * TILE_SIZE - camera.x;
  const screenY = player.y * TILE_SIZE - camera.y;

  ctx.fillStyle = "#ffcc00";
  ctx.fillRect(
    screenX,
    screenY,
    player.width * TILE_SIZE,
    player.height * TILE_SIZE
  );
}

// Kamera folgt Spieler
function updateCamera() {
  const targetX = player.x * TILE_SIZE + (player.width * TILE_SIZE) / 2 - canvas.width / 2;
  const targetY = player.y * TILE_SIZE + (player.height * TILE_SIZE) / 2 - canvas.height / 2;

  // weiches Folgen (lerp)
  const smoothing = 0.1;
  camera.x += (targetX - camera.x) * smoothing;
  camera.y += (targetY - camera.y) * smoothing;

  // Clamping an Weltgrenzen
  if (camera.x < 0) camera.x = 0;
  if (camera.y < 0) camera.y = 0;
  const maxCamX = WORLD_COLS * TILE_SIZE - canvas.width;
  const maxCamY = WORLD_ROWS * TILE_SIZE - canvas.height;
  if (camera.x > maxCamX) camera.x = maxCamX;
  if (camera.y > maxCamY) camera.y = maxCamY;
}

// einfache Kollision
function collides(px, py) {
  const left = Math.floor(px);
  const right = Math.floor(px + player.width - 0.001);
  const top = Math.floor(py);
  const bottom = Math.floor(py + player.height - 0.001);

  for (let y = top; y <= bottom; y++) {
    for (let x = left; x <= right; x++) {
      if (isSolid(x, y)) return true;
    }
  }
  return false;
}

// Bewegung
function movePlayer(dt) {
  const speed = 6;
  const jumpStrength = -11;
  const gravity = 25;

  player.vx = 0;
  if (keys["a"]) player.vx = -speed;
  if (keys["d"]) player.vx = speed;

  if (keys["w"] && player.onGround) {
    player.vy = jumpStrength;
    player.onGround = false;
  }

  player.vy += gravity * dt;

  // X
  let newX = player.x + player.vx * dt;
  if (!collides(newX, player.y)) {
    player.x = newX;
  }

  // Y
  let newY = player.y + player.vy * dt;
  if (!collides(player.x, newY)) {
    player.y = newY;
    player.onGround = false;
  } else {
    if (player.vy > 0) player.onGround = true;
    player.vy = 0;
  }
}

// Block-Platzierung / Abbau (mit Kamera berücksichtigen)
canvas.addEventListener("mousedown", e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const worldX = Math.floor((mx + camera.x) / TILE_SIZE);
  const worldY = Math.floor((my + camera.y) / TILE_SIZE);

  if (worldX < 0 || worldX >= WORLD_COLS || worldY < 0 || worldY >= WORLD_ROWS) return;

  if (e.button === 0) {
    // Links: abbauen
    world[worldY][worldX] = AIR;
  } else if (e.button === 2) {
    // Rechts: setzen
    if (!isPlayerInsideTile(worldX, worldY)) {
      const blockType = hotbarBlocks[selectedBlockIndex];
      world[worldY][worldX] = blockType;
    }
  }
});

canvas.addEventListener("contextmenu", e => e.preventDefault());

function isPlayerInsideTile(tx, ty) {
  const pxLeft = player.x;
  const pxRight = player.x + player.width;
  const pyTop = player.y;
  const pyBottom = player.y + player.height;

  const tileLeft = tx;
  const tileRight = tx + 1;
  const tileTop = ty;
  const tileBottom = ty + 1;

  const overlapX = pxLeft < tileRight && pxRight > tileLeft;
  const overlapY = pyTop < tileBottom && pyBottom > tileTop;

  return overlapX && overlapY;
}

// Game Loop
let lastTime = 0;
function loop(timestamp) {
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  movePlayer(dt);
  updateCamera();

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawWorld();
  drawPlayer();

  requestAnimationFrame(loop);
}

generateWorld();
selectHotbar(0);
requestAnimationFrame(loop);

 </scipt>
   
</html>
